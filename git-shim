#!/usr/bin/env bash
# git-shim
# Git does not allow aliases or user-defined subcommands to override existing subcommands
# To get around this, this script shims git and handles some subcommands
# Any operation not overriden will fall back to the actual git
# Additoinally, hooks are ran before and after the git call
# If a hook fails, our shim will stop before  the actual git command is executed
# Post hooks are only ran if the git command succeded
set -Eeuo pipefail


#echo "[debug] git exec: '$(command -v git)'"
#echo "[debug] git-track-repos exec: '$(command -v git-track-repos)'"

function pre_hooks() {
  local operation="$1"
  case "${operation}" in

    *)
      # No hooks yet
      ;;

  esac
}

function commit()
{
    if command -v cz &>/dev/null; then
      # Use commitizen to make the commit
      cz "${@}"
    else
      command git "${@}"
    fi
}

function overridden_git()
{
  local operation="$1"
  case "${operation}" in
    'commit')
      commit "${@}"
      ;;

    *)
      # Fall back to the actual git
      command git "${@}"
      ;;

  esac
}

function register_clonned_repo() {
  local git_args=("$@")
  # Parse the repo path we've cloned to
  # Try the last argument; It could be an explictly specified directory
  local repo_root="${git_args[-1]}"
  if [[ -d "${repo_root}" ]]; then
    git-track-repos --quiet --repo-root "${repo_root}" update
    return
  fi

  # Otherwise, we have to parse the repo name from the git url
  local url="${git_args[-1]}"
  repo_root="${url##*/}" # Strip everything before the last '/'
  repo_root="${repo_root%.git}" # Remove trailing '.git'
  echo "[debug] ${repo_root}"
  if [[ -d "${repo_root}" ]]; then
    git-track-repos --quiet --repo-root "${repo_root}" update
    return
  fi

  echo "Unable to find last clonned git dir"
  echo "Manually cd to it and run"
  echo "    $(which git-track-repos) register"
  echo "[debug] Git command '${git_args[*]}'"
  return 1
}

function register_new_repo()
{
  if [[ "$#" -gt 0 ]]; then
    local git_args=("$@")

    # Parse the repo path we've init'd
    # Try the last argument; It could be an explictly specified directory
    local repo_root="${git_args[-1]}"
    if [[ -d "${repo_root}" ]]; then
      git-track-repos --quiet --repo-root "${repo_root}" update
      return
    else
      echo "Unable to find last init'd git dir"
      echo "Manually cd to it and run"
      echo "    $(which git-track-repos) register"
      echo "[debug] Git command '${git_args[*]}'"
      return 1
    fi
  fi

  # Otherwise the working dir is our new repo
  git-track-repos --quiet
}

function post_hooks() {
  local operation="$1"
  case "${operation}" in

    'commit')
      # Update the entry in the database on each commit
      git-track-repos --quiet update
      ;;

    'clone')
      register_clonned_repo "$@"
      ;;

    'init')
      register_new_repo "$@"
      ;;

  esac
}

if [[ "$#" -eq 0 ]]; then
  echo "Must provide at least one argument"
  exit 2
fi

pre_hooks "${@}"
overridden_git "${@}"
post_hooks "${@}"

